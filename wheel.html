<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Wheel Syndicate</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-card: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent-green: #00d26a;
            --accent-red: #ff6b6b;
            --accent-yellow: #ffc107;
            --accent-blue: #4dabf7;
            --border-color: #2a2a4a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 1px solid var(--border-color);
        }

        header h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: var(--accent-green);
        }

        .status-dot.offline {
            background-color: var(--accent-red);
        }

        .status-dot.stale {
            background-color: var(--accent-yellow);
        }

        /* Summary Cards */
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .card {
            background-color: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .card-label {
            font-size: 12px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .card-value {
            font-size: 28px;
            font-weight: 600;
        }

        .card-value.positive {
            color: var(--accent-green);
        }

        .card-value.negative {
            color: var(--accent-red);
        }

        .card-value.warning {
            color: var(--accent-yellow);
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 4px;
            margin-bottom: 20px;
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 14px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent-blue);
            border-bottom-color: var(--accent-blue);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* Tables */
        .table-container {
            overflow-x: auto;
            margin-bottom: 24px;
        }

        .table-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-primary);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        th, td {
            padding: 12px 16px;
            text-align: left;
            border-bottom: 1px solid var(--border-color);
        }

        th {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
            font-weight: 500;
            text-transform: uppercase;
            font-size: 11px;
            letter-spacing: 0.5px;
        }

        tr:hover {
            background-color: rgba(255, 255, 255, 0.02);
        }

        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
        }

        .status-badge.otm {
            background-color: rgba(0, 210, 106, 0.2);
            color: var(--accent-green);
        }

        .status-badge.atm {
            background-color: rgba(255, 193, 7, 0.2);
            color: var(--accent-yellow);
        }

        .status-badge.itm {
            background-color: rgba(255, 107, 107, 0.2);
            color: var(--accent-red);
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 24px;
        }

        .chart-card {
            background-color: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .chart-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-primary);
        }

        .chart-container {
            position: relative;
            height: 250px;
        }

        /* Suggestions */
        .suggestions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 16px;
        }

        .suggestion-card {
            background-color: var(--bg-card);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .suggestion-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .suggestion-list {
            list-style: none;
        }

        .suggestion-list li {
            padding: 8px 0;
            border-bottom: 1px solid var(--border-color);
            font-size: 13px;
            color: var(--text-secondary);
        }

        .suggestion-list li:last-child {
            border-bottom: none;
        }

        .suggestion-list .ticker {
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Risk Metrics */
        .risk-section {
            margin-top: 24px;
        }

        .risk-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 16px;
        }

        .risk-item {
            background-color: var(--bg-secondary);
            padding: 16px;
            border-radius: 8px;
        }

        .risk-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .risk-value {
            font-size: 18px;
            font-weight: 600;
        }

        .progress-bar {
            height: 6px;
            background-color: var(--bg-primary);
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        /* Loading & Error States */
        .loading {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        .error-banner {
            background-color: rgba(255, 107, 107, 0.1);
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
            display: none;
        }

        .error-banner.visible {
            display: block;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--text-secondary);
        }

        /* Refresh button */
        .refresh-btn {
            background-color: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        .refresh-btn:hover {
            background-color: var(--bg-secondary);
        }

        .refresh-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .summary-cards {
                grid-template-columns: repeat(2, 1fr);
            }

            .charts-grid {
                grid-template-columns: 1fr;
            }

            .tabs {
                overflow-x: auto;
            }

            .tab {
                padding: 12px 16px;
                white-space: nowrap;
            }
        }

        /* Assignments Section */
        #assignmentsSection {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 193, 7, 0.1) 100%);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid var(--accent-yellow);
        }

        #assignmentsSection .table-title {
            color: var(--accent-yellow);
        }

        #assignmentsSection table {
            background: var(--bg-card);
            border-radius: 8px;
        }

        /* Activity Feed */
        .feed-container {
            max-height: 700px;
            overflow-y: auto;
        }

        .feed-filters {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .feed-filter {
            padding: 6px 14px;
            border-radius: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            font-size: 13px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .feed-filter:hover {
            border-color: var(--accent-blue);
            color: var(--text-primary);
        }

        .feed-filter.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }

        .feed-item {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 12px;
            transition: border-color 0.2s;
        }

        .feed-item:hover {
            border-color: var(--accent-blue);
        }

        .feed-item.credit {
            border-left: 3px solid var(--accent-green);
        }

        .feed-item.debit {
            border-left: 3px solid var(--accent-red);
        }

        .feed-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .feed-ticker {
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .feed-strategy {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .feed-strategy.csp { background: rgba(0, 210, 106, 0.15); color: var(--accent-green); }
        .feed-strategy.cc { background: rgba(77, 171, 247, 0.15); color: var(--accent-blue); }
        .feed-strategy.roll { background: rgba(255, 193, 7, 0.15); color: var(--accent-yellow); }

        .feed-description {
            font-size: 14px;
            line-height: 1.5;
            color: var(--text-primary);
            margin-bottom: 10px;
        }

        .feed-description strong {
            color: var(--accent-blue);
        }

        .feed-meta {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            color: var(--text-secondary);
        }

        .feed-premium {
            font-weight: 600;
            font-size: 14px;
        }

        .feed-premium.credit {
            color: var(--accent-green);
        }

        .feed-premium.debit {
            color: var(--accent-red);
        }

        .feed-date {
            font-size: 12px;
        }

        .feed-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }

        .feed-stat {
            background: var(--bg-card);
            border-radius: 8px;
            padding: 12px 16px;
            border: 1px solid var(--border-color);
        }

        .feed-stat-label {
            font-size: 11px;
            color: var(--text-secondary);
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .feed-stat-value {
            font-size: 20px;
            font-weight: 600;
        }

        /* Password Protection */
        .password-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 26, 46, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .password-overlay.hidden {
            display: none;
        }

        .password-box {
            background: var(--bg-card);
            padding: 40px;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .password-box h2 {
            margin-bottom: 8px;
            font-size: 20px;
        }

        .password-box p {
            color: var(--text-secondary);
            margin-bottom: 24px;
            font-size: 14px;
        }

        .password-input {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 16px;
            margin-bottom: 16px;
        }

        .password-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .password-submit {
            width: 100%;
            padding: 12px 16px;
            background: var(--accent-blue);
            border: none;
            border-radius: 6px;
            color: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .password-submit:hover {
            opacity: 0.9;
        }

        .password-error {
            color: var(--accent-red);
            font-size: 13px;
            margin-top: 12px;
            display: none;
        }

        .protected-content {
            filter: blur(10px);
            pointer-events: none;
            user-select: none;
        }

        .protected-content.unlocked {
            filter: none;
            pointer-events: auto;
            user-select: auto;
        }
    </style>
</head>
<body>
    <!-- Password Protection Overlay -->
    <div class="password-overlay" id="passwordOverlay">
        <div class="password-box">
            <h2>The Wheel Syndicate</h2>
            <p>Members only. Enter password to access.</p>
            <input type="password" class="password-input" id="passwordInput" placeholder="Enter password" onkeypress="if(event.key==='Enter')checkPassword()">
            <button class="password-submit" onclick="checkPassword()">Unlock</button>
            <div class="password-error" id="passwordError">Incorrect password</div>
        </div>
    </div>

    <div class="container">
        <!-- Header -->
        <header>
            <h1>The Wheel Syndicate</h1>
            <div style="display: flex; align-items: center; gap: 16px;">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Connected</span>
                </div>
                <button class="refresh-btn" id="refreshBtn" onclick="refreshData()">Refresh</button>
            </div>
        </header>

        <!-- Error Banner -->
        <div class="error-banner" id="errorBanner">
            <strong>API Offline</strong> - Unable to connect to the trading API. Showing cached data.
        </div>

        <!-- Summary Cards -->
        <div class="summary-cards">
            <div class="card">
                <div class="card-label">Portfolio Value</div>
                <div class="card-value" id="portfolioValue">$0.00</div>
            </div>
            <div class="card">
                <div class="card-label">Cumulative Premium (since Dec 29, 2025)</div>
                <div class="card-value positive" id="totalPremium">$0.00</div>
            </div>
            <div class="card">
                <div class="card-label">Active Positions</div>
                <div class="card-value" id="activePositions">0</div>
            </div>
            <div class="card">
                <div class="card-label">Days to Nearest Expiry</div>
                <div class="card-value" id="nearestExpiry">--</div>
            </div>
            <div class="card">
                <div class="card-label">Return Rate</div>
                <div class="card-value positive" id="returnRate">--%</div>
            </div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="positions">Positions</button>
            <button class="tab" data-tab="feed">Activity Feed</button>
            <button class="tab" data-tab="analytics">P&L Analytics</button>
            <button class="tab" data-tab="suggestions">Trade Suggestions</button>
        </div>

        <!-- Positions Tab -->
        <div class="tab-content active protected-content" id="positions-tab">
            <!-- Cash-Secured Puts -->
            <div class="table-container">
                <div class="table-title">Cash-Secured Puts (CSP)</div>
                <table>
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Strike</th>
                            <th>Stock Price</th>
                            <th>Expiry (DTE)</th>
                            <th>Premium</th>
                            <th>Premium Trend</th>
                            <th>Capital</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="cspTable">
                        <tr><td colspan="8" class="loading">Loading positions...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Covered Calls -->
            <div class="table-container">
                <div class="table-title">Covered Calls (CC)</div>
                <table>
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Strike</th>
                            <th>Stock Price</th>
                            <th>Expiry (DTE)</th>
                            <th>Premium</th>
                            <th>Premium Trend</th>
                            <th>Contracts</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="ccTable">
                        <tr><td colspan="8" class="loading">Loading positions...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Assigned Positions (Wheel in Progress) -->
            <div class="table-container" id="assignmentsSectionMain" style="background: linear-gradient(135deg, rgba(255, 107, 107, 0.1) 0%, rgba(255, 193, 7, 0.1) 100%); border-radius: 12px; padding: 16px; border: 1px solid var(--accent-yellow);">
                <div class="table-title" style="color: var(--accent-yellow); display: flex; justify-content: space-between; align-items: center;">
                    <span>Assigned Positions (Wheel in Progress)</span>
                    <span class="status-badge itm" style="font-size: 12px;">NEED COVERED CALLS</span>
                </div>
                <table style="background: var(--bg-card); border-radius: 8px;">
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Shares</th>
                            <th>Assigned Price</th>
                            <th>Current Price</th>
                            <th>Unrealized P&L</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="assignmentsTableMain">
                        <tr><td colspan="6" class="loading">Loading assignments...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Risk Metrics -->
            <div class="risk-section">
                <div class="table-title">Risk Metrics</div>
                <div class="risk-grid">
                    <div class="risk-item">
                        <div class="risk-label">Total Capital at Risk</div>
                        <div class="risk-value" id="totalCapitalRisk">$0.00</div>
                    </div>
                    <div class="risk-item">
                        <div class="risk-label">Largest Position Concentration</div>
                        <div class="risk-value" id="maxConcentration">0%</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="concentrationBar" style="width: 0%; background-color: var(--accent-green);"></div>
                        </div>
                    </div>
                    <div class="risk-item">
                        <div class="risk-label">Cash Available</div>
                        <div class="risk-value" id="cashAvailable">$0.00</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Analytics Tab -->
        <div class="tab-content" id="analytics-tab">
            <div class="charts-grid">
                <div class="chart-card" style="grid-column: span 2;">
                    <div class="chart-title">Cumulative Premium by Ticker</div>
                    <div class="chart-container" style="height: 300px;">
                        <canvas id="premiumTrendChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Win Rate</div>
                    <div class="chart-container">
                        <canvas id="winRateChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">ROI by Ticker</div>
                    <div class="chart-container">
                        <canvas id="roiChart"></canvas>
                    </div>
                </div>
                <div class="chart-card">
                    <div class="chart-title">Cumulative P&L</div>
                    <div class="chart-container">
                        <canvas id="plChart"></canvas>
                    </div>
                </div>
                <div class="chart-card" style="grid-column: span 2;">
                    <div class="chart-title">Premium by Contract</div>
                    <div class="chart-container" style="height: 350px;">
                        <canvas id="contractTrendChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Suggestions Tab -->
        <div class="tab-content" id="suggestions-tab">
            <div class="suggestions-grid">
                <div class="suggestion-card">
                    <div class="suggestion-title">
                        <span style="color: var(--accent-green);">&#9650;</span>
                        High IV Candidates for CSPs
                    </div>
                    <ul class="suggestion-list" id="highIvList">
                        <li>Loading suggestions...</li>
                    </ul>
                </div>
                <div class="suggestion-card">
                    <div class="suggestion-title">
                        <span style="color: var(--accent-yellow);">&#9888;</span>
                        Approaching Expiration (Roll Candidates)
                    </div>
                    <ul class="suggestion-list" id="rollCandidates">
                        <li>Loading suggestions...</li>
                    </ul>
                </div>
                <div class="suggestion-card">
                    <div class="suggestion-title">
                        <span style="color: var(--accent-red);">&#9679;</span>
                        ITM Positions Requiring Attention
                    </div>
                    <ul class="suggestion-list" id="itmPositions">
                        <li>Loading suggestions...</li>
                    </ul>
                </div>
                <div class="suggestion-card">
                    <div class="suggestion-title">
                        <span style="color: var(--accent-blue);">&#9632;</span>
                        Position Sizing Recommendations
                    </div>
                    <ul class="suggestion-list" id="sizingRecommendations">
                        <li>Loading suggestions...</li>
                    </ul>
                </div>
            </div>
        </div>

        <!-- Activity Feed Tab -->
        <div class="tab-content" id="feed-tab">
            <!-- Stats -->
            <div class="feed-stats">
                <div class="feed-stat">
                    <div class="feed-stat-label">Total Orders</div>
                    <div class="feed-stat-value" id="feedTotalOrders">0</div>
                </div>
                <div class="feed-stat">
                    <div class="feed-stat-label">Filled Orders</div>
                    <div class="feed-stat-value" id="feedFilledOrders">0</div>
                </div>
                <div class="feed-stat">
                    <div class="feed-stat-label">Total Premium Collected</div>
                    <div class="feed-stat-value positive" id="feedTotalPremium">$0</div>
                </div>
                <div class="feed-stat">
                    <div class="feed-stat-label">Last Activity</div>
                    <div class="feed-stat-value" id="feedLastActivity">--</div>
                </div>
            </div>

            <!-- Assignments Section -->
            <div class="table-container" id="assignmentsSection" style="margin-bottom: 24px;">
                <div class="table-title" style="display: flex; justify-content: space-between; align-items: center;">
                    <span>Assigned Positions (Puts Exercised)</span>
                    <span class="status-badge itm" style="font-size: 12px;">WHEEL IN PROGRESS</span>
                </div>
                <table>
                    <thead>
                        <tr>
                            <th>Ticker</th>
                            <th>Shares</th>
                            <th>Assigned Price</th>
                            <th>Current Price</th>
                            <th>Unrealized P&L</th>
                            <th>Status</th>
                        </tr>
                    </thead>
                    <tbody id="assignmentsTable">
                        <tr><td colspan="6" class="loading">Loading assignments...</td></tr>
                    </tbody>
                </table>
            </div>

            <!-- Filters -->
            <div class="feed-filters">
                <button class="feed-filter active" data-filter="all">All Orders</button>
                <button class="feed-filter" data-filter="filled">Filled</button>
                <button class="feed-filter" data-filter="pending">Pending</button>
                <button class="feed-filter" data-filter="cancelled">Cancelled</button>
            </div>

            <!-- Feed Items -->
            <div class="feed-container" id="feedContainer">
                <div class="loading">Loading activity feed...</div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'https://api.arunash.com/api';
        const REFRESH_INTERVAL = 60000; // 60 seconds
        const CACHE_KEY = 'wheelDashboardCache';
        const DASHBOARD_PASSWORD = 'wheel2025';  // Change this password
        const PASSWORD_SESSION_KEY = 'wheelDashboardAuth';

        // Password Protection
        function checkPassword() {
            const input = document.getElementById('passwordInput');
            const error = document.getElementById('passwordError');
            if (input.value === DASHBOARD_PASSWORD) {
                sessionStorage.setItem(PASSWORD_SESSION_KEY, 'true');
                unlockDashboard();
            } else {
                error.style.display = 'block';
                input.value = '';
                setTimeout(() => error.style.display = 'none', 3000);
            }
        }

        function unlockDashboard() {
            document.getElementById('passwordOverlay').classList.add('hidden');
            document.getElementById('positions-tab').classList.add('unlocked');
        }

        function checkAuthOnLoad() {
            if (sessionStorage.getItem(PASSWORD_SESSION_KEY) === 'true') {
                unlockDashboard();
            }
        }

        // State
        let portfolioData = null;
        let optionsPositions = [];
        let optionsOrders = [];
        let lastFetchTime = null;
        let refreshTimer = null;
        let charts = {};

        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`${tab.dataset.tab}-tab`).classList.add('active');
            });
        });

        // API Functions
        async function fetchPortfolio() {
            const res = await fetch(`${API_BASE}/portfolio`);
            if (!res.ok) throw new Error('Failed to fetch portfolio');
            const json = await res.json();
            if (!json.success) throw new Error(json.error || 'API error');
            return json.data;
        }

        async function fetchOptionsPositions() {
            const res = await fetch(`${API_BASE}/options/positions`);
            if (!res.ok) throw new Error('Failed to fetch options positions');
            const json = await res.json();
            if (!json.success) throw new Error(json.error || 'API error');
            return json.data || [];
        }

        const ORDERS_STORAGE_KEY = 'wheelDashboardOrders';

        // Load stored orders from localStorage
        function loadStoredOrders() {
            try {
                const stored = localStorage.getItem(ORDERS_STORAGE_KEY);
                if (stored) {
                    return JSON.parse(stored);
                }
            } catch (e) {
                console.warn('Failed to load stored orders:', e);
            }
            return [];
        }

        // Save orders to localStorage
        function saveOrdersToStorage(orders) {
            try {
                localStorage.setItem(ORDERS_STORAGE_KEY, JSON.stringify(orders));
                console.log(`Saved ${orders.length} orders to local storage`);
            } catch (e) {
                console.warn('Failed to save orders to storage:', e);
            }
        }

        // Merge new orders with stored orders (avoid duplicates by order ID)
        function mergeOrders(storedOrders, newOrders) {
            const orderMap = new Map();

            // Add stored orders first
            storedOrders.forEach(order => {
                if (order.id) {
                    orderMap.set(order.id, order);
                }
            });

            // Add/update with new orders
            newOrders.forEach(order => {
                if (order.id) {
                    orderMap.set(order.id, order);
                }
            });

            return Array.from(orderMap.values());
        }

        async function fetchOptionsOrders() {
            // Load previously stored orders
            const storedOrders = loadStoredOrders();

            let newOrders = [];
            let url = `${API_BASE}/options/orders`;

            // Fetch current orders from API
            while (url) {
                const res = await fetch(url);
                if (!res.ok) throw new Error('Failed to fetch options orders');
                const json = await res.json();
                if (!json.success) throw new Error(json.error || 'API error');

                const orders = json.data || [];
                newOrders.push(...orders);

                // Check for next page (Robinhood returns 'next' URL for pagination)
                url = json.next || null;
            }

            // Merge stored orders with new orders
            const allOrders = mergeOrders(storedOrders, newOrders);

            // Save merged orders back to storage
            saveOrdersToStorage(allOrders);

            console.log(`Orders: ${storedOrders.length} stored + ${newOrders.length} from API = ${allOrders.length} total`);

            return allOrders;
        }

        // Utility Functions
        function formatCurrency(value) {
            const num = parseFloat(value) || 0;
            return new Intl.NumberFormat('en-US', {
                style: 'currency',
                currency: 'USD'
            }).format(num);
        }

        function formatDate(dateStr) {
            if (!dateStr) return '--';
            const date = new Date(dateStr);
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: '2-digit' });
        }

        function calculateDTE(expirationDate) {
            if (!expirationDate) return null;
            const expiry = new Date(expirationDate);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            expiry.setHours(0, 0, 0, 0);
            const diffTime = expiry - today;
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
            return diffDays;
        }

        function getMoneyStatus(optionType, strike, currentPrice) {
            if (!strike || !currentPrice) return 'unknown';
            const strikePx = parseFloat(strike);
            const pricePx = parseFloat(currentPrice);
            const diff = Math.abs(strikePx - pricePx) / pricePx;

            if (diff < 0.02) return 'atm';

            if (optionType === 'put') {
                return strikePx < pricePx ? 'otm' : 'itm';
            } else {
                return strikePx > pricePx ? 'otm' : 'itm';
            }
        }

        function updateStatus(status, message) {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');
            dot.className = 'status-dot ' + status;
            text.textContent = message;
        }

        // Data Processing
        function processPositions(positions, stockPrices = {}) {
            const csps = [];
            const ccs = [];

            if (!positions || !Array.isArray(positions)) {
                return { csps, ccs };
            }

            positions.forEach(pos => {
                const quantity = parseFloat(pos.quantity) || 0;
                if (quantity === 0) return;

                const ticker = pos.chain_symbol || pos.symbol || 'Unknown';
                const strike = parseFloat(pos.strike_price) || 0;
                const stockPrice = stockPrices[ticker] || 0;

                const optionData = {
                    ticker: ticker,
                    strike: strike,
                    expiration: pos.expiration_date,
                    premium: Math.abs(parseFloat(pos.average_price) || 0) * Math.abs(quantity),
                    quantity: Math.abs(quantity),
                    type: pos.type,
                    dte: calculateDTE(pos.expiration_date),
                    currentPrice: parseFloat(pos.adjusted_mark_price) || 0,
                    stockPrice: stockPrice
                };

                // Calculate capital at risk for puts
                optionData.capitalAtRisk = optionData.strike * 100 * optionData.quantity;

                // Determine ITM/OTM status based on current stock price
                if (stockPrice > 0) {
                    if (pos.type === 'put') {
                        // Put is ITM when stock price < strike
                        optionData.status = stockPrice < strike ? 'itm' : 'otm';
                    } else if (pos.type === 'call') {
                        // Call is ITM when stock price > strike
                        optionData.status = stockPrice > strike ? 'itm' : 'otm';
                    }
                    // Check if ATM (within 2%)
                    const diff = Math.abs(stockPrice - strike) / stockPrice;
                    if (diff < 0.02) optionData.status = 'atm';
                } else {
                    optionData.status = 'unknown';
                }

                if (pos.type === 'put') {
                    csps.push(optionData);
                } else if (pos.type === 'call') {
                    ccs.push(optionData);
                }
            });

            return { csps, ccs };
        }

        // Extract stock prices from portfolio positions
        function getStockPrices(portfolio) {
            const prices = {};
            if (portfolio && portfolio.positions) {
                portfolio.positions.forEach(pos => {
                    prices[pos.symbol] = pos.market_price;
                });
            }
            return prices;
        }

        function processOrders(orders) {
            if (!orders || !Array.isArray(orders)) return [];

            return orders
                .filter(order => order.state === 'filled')
                .map(order => {
                    const numLegs = order.legs?.length || 0;
                    const isMultiLeg = numLegs > 1;
                    const isRoll = order.closing_strategy !== null;
                    const isCredit = order.direction === 'credit' || order.processed_premium_direction === 'credit';

                    // For multi-leg (rolls), get both buy and sell leg info
                    const buyLeg = order.legs?.find(l => l.side === 'buy');
                    const sellLeg = order.legs?.find(l => l.side === 'sell');

                    let optionType = 'unknown';
                    let strike = 0;
                    let expiration = null;

                    if (isMultiLeg && sellLeg) {
                        // For rolls, use the sell leg (new position) for matching
                        optionType = sellLeg.option_type || 'unknown';
                        strike = parseFloat(sellLeg.strike_price) || 0;
                        expiration = sellLeg.expiration_date || null;
                    } else {
                        // For single-leg orders, use legs[0]
                        optionType = order.legs?.[0]?.option_type || 'unknown';
                        strike = parseFloat(order.legs?.[0]?.strike_price) || 0;
                        expiration = order.legs?.[0]?.expiration_date || null;
                    }

                    return {
                        ticker: order.chain_symbol || 'Unknown',
                        type: optionType,
                        action: order.legs?.[0]?.side || 'unknown',
                        strike: strike,
                        buyStrike: buyLeg ? parseFloat(buyLeg.strike_price) || 0 : null,
                        sellStrike: sellLeg ? parseFloat(sellLeg.strike_price) || 0 : null,
                        expiration: expiration,
                        premium: parseFloat(order.premium) || 0,
                        quantity: parseFloat(order.quantity) || 0,
                        processedPremium: parseFloat(order.processed_premium) || 0,
                        createdAt: new Date(order.created_at),
                        closingStrategy: order.closing_strategy,
                        isRoll: isRoll,
                        isMultiLeg: isMultiLeg,
                        isCredit: isCredit
                    };
                });
        }

        // Render Functions
        // Get weekly premium data for a specific contract (ticker + strike + type)
        function getWeeklyPremiumData(ticker, strike, expiration, optionType = 'put') {
            const filledOrders = processOrders(optionsOrders);

            // Match by ticker, option type, AND strike price
            const matchingOrders = filledOrders
                .filter(o => {
                    if (o.ticker !== ticker || o.type !== optionType) return false;
                    // Match strike with small tolerance for floating point
                    if (Math.abs(o.strike - strike) > 0.01) return false;
                    return true;
                })
                .sort((a, b) => a.createdAt - b.createdAt);

            if (matchingOrders.length === 0) return { openingValues: [], rollValues: [], labels: [] };
            return buildWeeklyData(matchingOrders);
        }

        function buildWeeklyData(orders) {
            if (!orders || orders.length === 0) return { openingValues: [], rollValues: [], labels: [] };

            const weeklyOpening = {};
            const weeklyRoll = {};

            // Sum premium by week, separated by opening vs roll
            orders.forEach(order => {
                const orderDate = order.createdAt;
                const weekStart = new Date(orderDate);
                weekStart.setDate(weekStart.getDate() - weekStart.getDay());
                const weekKey = weekStart.toISOString().split('T')[0];

                // Use direction to determine credit (+) or debit (-)
                const premiumValue = order.isCredit
                    ? order.processedPremium
                    : -order.processedPremium;

                if (order.isRoll) {
                    weeklyRoll[weekKey] = (weeklyRoll[weekKey] || 0) + premiumValue;
                } else {
                    weeklyOpening[weekKey] = (weeklyOpening[weekKey] || 0) + premiumValue;
                }
            });

            // Get all unique weeks
            const allWeeks = new Set([...Object.keys(weeklyOpening), ...Object.keys(weeklyRoll)]);
            const sortedWeeks = [...allWeeks].sort();

            const openingValues = [];
            const rollValues = [];
            const labels = [];

            sortedWeeks.forEach(weekKey => {
                const date = new Date(weekKey + 'T00:00:00');
                openingValues.push(weeklyOpening[weekKey] || 0);
                rollValues.push(weeklyRoll[weekKey] || 0);
                labels.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
            });

            return { openingValues, rollValues, labels };
        }

        // Store sparkline chart instances for cleanup
        const sparklineCharts = {};

        // Render sparkline chart
        function renderSparkline(canvasId, data) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;

            // Destroy existing chart if any
            if (sparklineCharts[canvasId]) {
                sparklineCharts[canvasId].destroy();
            }

            const openingValues = data?.openingValues || [];
            const rollValues = data?.rollValues || [];
            const labels = data?.labels || [];

            // Show placeholder if no data
            const hasData = openingValues.some(v => v > 0) || rollValues.some(v => v > 0);
            if (!hasData) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '11px sans-serif';
                ctx.fillText('No data', 5, 25);
                return;
            }

            // Color positive (credit) green, negative (debit) red
            const openingColors = openingValues.map(v => v >= 0 ? '#4dabf7' : '#ff6b6b');
            const rollColors = rollValues.map(v => v >= 0 ? '#00d26a' : '#ff6b6b');

            sparklineCharts[canvasId] = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Opening',
                            data: openingValues,
                            backgroundColor: openingColors,
                            borderRadius: 2,
                            barPercentage: 0.9
                        },
                        {
                            label: 'Roll',
                            data: rollValues,
                            backgroundColor: rollColors,
                            borderRadius: 2,
                            barPercentage: 0.9
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            enabled: true,
                            callbacks: {
                                label: function(context) {
                                    const type = context.dataset.label;
                                    const value = context.raw;
                                    const sign = value >= 0 ? '+' : '';
                                    return type + ': ' + sign + '$' + value.toLocaleString();
                                }
                            }
                        }
                    },
                    scales: {
                        x: { display: false, stacked: true },
                        y: { display: false, beginAtZero: true, stacked: true }
                    }
                }
            });
        }

        function renderCSPTable(csps) {
            const tbody = document.getElementById('cspTable');

            if (!csps || csps.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="empty-state">No cash-secured put positions</td></tr>';
                return;
            }

            tbody.innerHTML = csps.map((pos, idx) => `
                <tr>
                    <td><strong>${pos.ticker}</strong></td>
                    <td>${formatCurrency(pos.strike)}</td>
                    <td>${pos.stockPrice ? formatCurrency(pos.stockPrice) : '--'}</td>
                    <td class="${pos.dte <= 7 ? 'warning' : ''}">${formatDate(pos.expiration)} <span style="opacity: 0.7;">(${pos.dte !== null ? pos.dte + 'd' : '--'})</span></td>
                    <td class="positive">${formatCurrency(pos.premium)}</td>
                    <td style="width: 200px; padding: 4px;">
                        <div style="height: 50px; width: 180px; position: relative;">
                            <canvas id="sparkline-csp-${idx}" width="180" height="50"></canvas>
                        </div>
                    </td>
                    <td style="font-size: 12px;">${formatCurrency(pos.capitalAtRisk)}</td>
                    <td><span class="status-badge ${pos.status}">${pos.status.toUpperCase()}</span></td>
                </tr>
            `).join('');

            // Render sparklines after DOM is updated
            setTimeout(() => {
                csps.forEach((pos, idx) => {
                    const weeklyData = getWeeklyPremiumData(pos.ticker, pos.strike, pos.expiration, 'put');
                    renderSparkline(`sparkline-csp-${idx}`, weeklyData);
                });
            }, 0);
        }

        function renderCCTable(ccs) {
            const tbody = document.getElementById('ccTable');

            if (!ccs || ccs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="8" class="empty-state">No covered call positions</td></tr>';
                return;
            }

            tbody.innerHTML = ccs.map((pos, idx) => `
                <tr>
                    <td><strong>${pos.ticker}</strong></td>
                    <td>${formatCurrency(pos.strike)}</td>
                    <td>${pos.stockPrice ? formatCurrency(pos.stockPrice) : '--'}</td>
                    <td class="${pos.dte <= 7 ? 'warning' : ''}">${formatDate(pos.expiration)} <span style="opacity: 0.7;">(${pos.dte !== null ? pos.dte + 'd' : '--'})</span></td>
                    <td class="positive">${formatCurrency(pos.premium)}</td>
                    <td style="width: 200px; padding: 4px;">
                        <div style="height: 50px; width: 180px; position: relative;">
                            <canvas id="sparkline-cc-${idx}" width="180" height="50"></canvas>
                        </div>
                    </td>
                    <td>${pos.quantity}</td>
                    <td><span class="status-badge ${pos.status}">${pos.status.toUpperCase()}</span></td>
                </tr>
            `).join('');

            // Render sparklines after DOM is updated
            setTimeout(() => {
                ccs.forEach((pos, idx) => {
                    const weeklyData = getWeeklyPremiumData(pos.ticker, pos.strike, pos.expiration, 'call');
                    renderSparkline(`sparkline-cc-${idx}`, weeklyData);
                });
            }, 0);
        }

        function renderSummaryCards(portfolio, positions, stockPrices = {}) {
            // Portfolio value
            const portfolioValue = portfolio?.total_equity || portfolio?.equity || 0;
            document.getElementById('portfolioValue').textContent = formatCurrency(portfolioValue);

            // Calculate cumulative premium (credits received)
            const filledOrders = processOrders(optionsOrders);
            const totalPremium = filledOrders
                .filter(o => o.isCredit)
                .reduce((sum, o) => sum + o.processedPremium, 0);
            document.getElementById('totalPremium').textContent = formatCurrency(totalPremium);

            // Calculate return rate (cumulative premium / portfolio value)
            const returnRate = portfolioValue > 0 ? (totalPremium / portfolioValue) * 100 : 0;
            const returnElem = document.getElementById('returnRate');
            returnElem.textContent = returnRate.toFixed(2) + '%';
            if (returnRate >= 5) {
                returnElem.className = 'card-value positive';
            } else if (returnRate >= 2) {
                returnElem.className = 'card-value warning';
            } else {
                returnElem.className = 'card-value';
            }

            // Active positions count
            const activeCount = positions?.length || 0;
            document.getElementById('activePositions').textContent = activeCount;

            // Nearest expiry
            const { csps, ccs } = processPositions(positions, stockPrices);
            const allPositions = [...csps, ...ccs];
            const dtes = allPositions.map(p => p.dte).filter(d => d !== null && d >= 0);
            const nearestDte = dtes.length > 0 ? Math.min(...dtes) : null;

            const nearestElem = document.getElementById('nearestExpiry');
            if (nearestDte !== null) {
                nearestElem.textContent = nearestDte;
                if (nearestDte <= 3) {
                    nearestElem.className = 'card-value negative';
                } else if (nearestDte <= 7) {
                    nearestElem.className = 'card-value warning';
                } else {
                    nearestElem.className = 'card-value';
                }
            } else {
                nearestElem.textContent = '--';
                nearestElem.className = 'card-value';
            }

            // Cash available
            document.getElementById('cashAvailable').textContent = formatCurrency(portfolio?.cash || 0);

            // Total capital at risk
            const totalRisk = csps.reduce((sum, p) => sum + p.capitalAtRisk, 0);
            document.getElementById('totalCapitalRisk').textContent = formatCurrency(totalRisk);

            // Concentration
            const tickerRisks = {};
            csps.forEach(p => {
                tickerRisks[p.ticker] = (tickerRisks[p.ticker] || 0) + p.capitalAtRisk;
            });
            const maxRisk = Math.max(...Object.values(tickerRisks), 0);
            const concentration = totalRisk > 0 ? (maxRisk / totalRisk * 100) : 0;
            document.getElementById('maxConcentration').textContent = concentration.toFixed(1) + '%';

            const concBar = document.getElementById('concentrationBar');
            concBar.style.width = concentration + '%';
            if (concentration > 30) {
                concBar.style.backgroundColor = 'var(--accent-red)';
            } else if (concentration > 20) {
                concBar.style.backgroundColor = 'var(--accent-yellow)';
            } else {
                concBar.style.backgroundColor = 'var(--accent-green)';
            }
        }

        function renderSuggestions(positions, orders, stockPrices = {}) {
            const { csps, ccs } = processPositions(positions, stockPrices);
            const allPositions = [...csps, ...ccs];

            // Roll candidates (DTE <= 7)
            const rollCandidates = allPositions.filter(p => p.dte !== null && p.dte <= 7 && p.dte >= 0);
            const rollList = document.getElementById('rollCandidates');
            if (rollCandidates.length > 0) {
                rollList.innerHTML = rollCandidates.map(p => `
                    <li><span class="ticker">${p.ticker}</span> - ${p.type === 'put' ? 'CSP' : 'CC'} $${p.strike} expires in <strong>${p.dte}</strong> days</li>
                `).join('');
            } else {
                rollList.innerHTML = '<li>No positions approaching expiration</li>';
            }

            // ITM positions
            const itmList = document.getElementById('itmPositions');
            const itmPositions = allPositions.filter(p => p.status === 'itm');
            if (itmPositions.length > 0) {
                itmList.innerHTML = itmPositions.map(p => `
                    <li><span class="ticker">${p.ticker}</span> - ${p.type === 'put' ? 'CSP' : 'CC'} $${p.strike} is ITM</li>
                `).join('');
            } else {
                itmList.innerHTML = '<li>No ITM positions - all safe!</li>';
            }

            // High IV candidates (placeholder - would need IV data)
            const highIvList = document.getElementById('highIvList');
            highIvList.innerHTML = '<li>Connect to options chain data for IV analysis</li>';

            // Position sizing
            const sizingList = document.getElementById('sizingRecommendations');
            const cash = portfolioData?.cash || 0;
            if (cash > 5000) {
                sizingList.innerHTML = `
                    <li>Available cash: <strong>${formatCurrency(cash)}</strong></li>
                    <li>Max recommended CSP size: <strong>${formatCurrency(cash * 0.25)}</strong> (25% rule)</li>
                    <li>Consider diversifying across 3-4 underlyings</li>
                `;
            } else {
                sizingList.innerHTML = '<li>Limited cash available for new positions</li>';
            }
        }

        function renderCharts(orders) {
            const filledOrders = processOrders(orders);

            // Cumulative premium trend by ticker (credits only)
            const creditOrders = filledOrders
                .filter(o => o.isCredit)
                .sort((a, b) => a.createdAt - b.createdAt);

            // Get unique tickers and assign colors
            const tickers = [...new Set(creditOrders.map(o => o.ticker))];
            const colorPalette = [
                '#00d26a', '#4dabf7', '#ff6b6b', '#ffc107', '#a855f7',
                '#f472b6', '#22d3d8', '#fb923c', '#84cc16', '#6366f1'
            ];

            // Build cumulative data per ticker
            const tickerCumulatives = {};
            tickers.forEach(t => tickerCumulatives[t] = { cumulative: 0, data: [] });

            // Get all unique dates
            const allDates = [...new Set(creditOrders.map(o => o.createdAt.toISOString().split('T')[0]))].sort();

            // For each date, update cumulative for each ticker
            allDates.forEach(date => {
                const ordersOnDate = creditOrders.filter(o => o.createdAt.toISOString().split('T')[0] === date);

                // Add premium for orders on this date
                ordersOnDate.forEach(order => {
                    tickerCumulatives[order.ticker].cumulative += order.processedPremium;
                });

                // Record cumulative value for each ticker at this date
                tickers.forEach(ticker => {
                    tickerCumulatives[ticker].data.push(tickerCumulatives[ticker].cumulative);
                });
            });

            // Create datasets for Chart.js
            const datasets = tickers.map((ticker, idx) => ({
                label: ticker,
                data: tickerCumulatives[ticker].data,
                borderColor: colorPalette[idx % colorPalette.length],
                backgroundColor: 'transparent',
                tension: 0.3,
                pointRadius: 2,
                pointHoverRadius: 5
            }));

            const dateLabels = allDates.map(d => {
                const date = new Date(d);
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });

            if (charts.premiumTrendChart) charts.premiumTrendChart.destroy();
            charts.premiumTrendChart = new Chart(document.getElementById('premiumTrendChart'), {
                type: 'line',
                data: {
                    labels: dateLabels.length ? dateLabels : ['No Data'],
                    datasets: datasets.length ? datasets : [{ label: 'No Data', data: [0] }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#a0a0a0', usePointStyle: true }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${formatCurrency(context.raw)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            ticks: {
                                color: '#a0a0a0',
                                callback: function(value) { return '$' + value.toLocaleString(); }
                            },
                            grid: { color: '#2a2a4a' }
                        },
                        x: {
                            ticks: { color: '#a0a0a0', maxTicksLimit: 10 },
                            grid: { display: false }
                        }
                    }
                }
            });

            // Win rate
            const wins = filledOrders.filter(o => o.closingStrategy !== null || o.processedPremium > 0).length;
            const losses = filledOrders.length - wins;

            if (charts.winRateChart) charts.winRateChart.destroy();
            charts.winRateChart = new Chart(document.getElementById('winRateChart'), {
                type: 'doughnut',
                data: {
                    labels: ['Wins', 'Losses'],
                    datasets: [{
                        data: [wins || 1, losses],
                        backgroundColor: ['#00d26a', '#ff6b6b']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: { color: '#a0a0a0' }
                        }
                    }
                }
            });

            // ROI by ticker (credits only)
            const tickerPremium = {};
            filledOrders
                .filter(o => o.isCredit)
                .forEach(order => {
                    tickerPremium[order.ticker] = (tickerPremium[order.ticker] || 0) + order.processedPremium;
                });

            // Sort by premium and show all tickers
            const roiLabels = Object.keys(tickerPremium).sort((a, b) => tickerPremium[b] - tickerPremium[a]);
            const roiData = roiLabels.map(k => tickerPremium[k]);

            if (charts.roiChart) charts.roiChart.destroy();
            charts.roiChart = new Chart(document.getElementById('roiChart'), {
                type: 'bar',
                data: {
                    labels: roiLabels.length ? roiLabels : ['No Data'],
                    datasets: [{
                        label: 'Premium',
                        data: roiData.length ? roiData : [0],
                        backgroundColor: '#4dabf7'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a4a' } },
                        y: { ticks: { color: '#a0a0a0' }, grid: { display: false } }
                    }
                }
            });

            // Cumulative P&L (credits since Dec 29, 2025)
            const sortedOrders = [...filledOrders]
                .filter(o => o.isCredit)
                .sort((a, b) => a.createdAt - b.createdAt);

            let cumulative = 0;
            const plData = sortedOrders.map(o => {
                cumulative += o.processedPremium;
                return cumulative;
            });
            const plLabels = sortedOrders.map(o => formatDate(o.createdAt));

            if (charts.plChart) charts.plChart.destroy();
            charts.plChart = new Chart(document.getElementById('plChart'), {
                type: 'line',
                data: {
                    labels: plLabels.length ? plLabels : ['Start'],
                    datasets: [{
                        label: 'Cumulative P&L',
                        data: plData.length ? plData : [0],
                        borderColor: '#00d26a',
                        backgroundColor: 'rgba(0, 210, 106, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { ticks: { color: '#a0a0a0' }, grid: { color: '#2a2a4a' } },
                        x: { ticks: { color: '#a0a0a0', maxTicksLimit: 6 }, grid: { display: false } }
                    }
                }
            });

            // Premium by Contract (per ticker, per strike) - shows actual premium per transaction
            const contractOrders = filledOrders
                .filter(o => o.isCredit)
                .sort((a, b) => a.createdAt - b.createdAt);

            // Group by contract (ticker + type + strike)
            const contractMap = {};
            let totalByContract = {};
            contractOrders.forEach(order => {
                const contractKey = `${order.ticker} ${order.type === 'put' ? 'P' : 'C'} $${order.strike}`;
                if (!contractMap[contractKey]) {
                    contractMap[contractKey] = { ticker: order.ticker, orders: [] };
                    totalByContract[contractKey] = 0;
                }
                contractMap[contractKey].orders.push(order);
                totalByContract[contractKey] += order.processedPremium;
            });

            // Sort contracts by total premium
            const sortedContracts = Object.keys(contractMap)
                .sort((a, b) => totalByContract[b] - totalByContract[a]);

            // Create bar chart data - one bar per contract showing total premium
            const tickerColors = {
                'PLTR': '#00d26a', 'HOOD': '#4dabf7', 'NVDA': '#ff6b6b',
                'TSLA': '#ffc107', 'UBER': '#a855f7', 'GOOG': '#f472b6'
            };
            const defaultColors = ['#22d3d8', '#fb923c', '#84cc16', '#6366f1'];

            const contractLabels = sortedContracts;
            const contractData = sortedContracts.map(key => totalByContract[key]);
            const contractColors = sortedContracts.map((key, idx) => {
                const ticker = contractMap[key].ticker;
                return tickerColors[ticker] || defaultColors[idx % defaultColors.length];
            });

            if (charts.contractTrendChart) charts.contractTrendChart.destroy();
            charts.contractTrendChart = new Chart(document.getElementById('contractTrendChart'), {
                type: 'bar',
                data: {
                    labels: contractLabels.length ? contractLabels : ['No Data'],
                    datasets: [{
                        label: 'Premium',
                        data: contractData.length ? contractData : [0],
                        backgroundColor: contractColors,
                        borderRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Premium: $${context.raw.toLocaleString()}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#a0a0a0',
                                callback: function(value) { return '$' + value.toLocaleString(); }
                            },
                            grid: { color: '#2a2a4a' }
                        },
                        y: {
                            ticks: { color: '#a0a0a0', font: { size: 11 } },
                            grid: { display: false }
                        }
                    }
                }
            });
        }

        // Assignments tracking
        function renderAssignments(portfolio) {
            const tbody = document.getElementById('assignmentsTable');
            const tbodyMain = document.getElementById('assignmentsTableMain');
            const sectionMain = document.getElementById('assignmentsSectionMain');

            const emptyMsg = '<tr><td colspan="6" class="empty-state">No portfolio data</td></tr>';
            const noAssignmentsMsg = '<tr><td colspan="6" class="empty-state">No assigned positions - all puts expired OTM!</td></tr>';

            if (!portfolio || !portfolio.positions) {
                if (tbody) tbody.innerHTML = emptyMsg;
                if (tbodyMain) tbodyMain.innerHTML = emptyMsg;
                return;
            }

            // Filter positions that look like assignments (shares owned with avg price significantly above current)
            // These are stocks acquired from put assignments
            const assignments = portfolio.positions.filter(pos => {
                const shares = parseFloat(pos.quantity) || 0;
                const avgPrice = parseFloat(pos.average_price) || 0;
                const currentPrice = parseFloat(pos.market_price) || 0;

                // Must have shares and average price > current price (underwater from assignment)
                // Also filter out small positions (fractional shares from dividends etc)
                return shares >= 100 && avgPrice > currentPrice * 1.05;
            });

            if (assignments.length === 0) {
                if (tbody) tbody.innerHTML = noAssignmentsMsg;
                if (tbodyMain) tbodyMain.innerHTML = noAssignmentsMsg;
                if (sectionMain) sectionMain.style.display = 'none';
                return;
            }

            // Show the section if there are assignments
            if (sectionMain) sectionMain.style.display = 'block';

            const html = assignments.map(pos => {
                const shares = parseFloat(pos.quantity) || 0;
                const avgPrice = parseFloat(pos.average_price) || 0;
                const currentPrice = parseFloat(pos.market_price) || 0;
                const unrealizedPL = parseFloat(pos.unrealized_pl) || 0;
                const plClass = unrealizedPL >= 0 ? 'positive' : 'negative';
                const plSign = unrealizedPL >= 0 ? '+' : '';

                // Estimate contracts assigned (100 shares per contract)
                const contracts = Math.round(shares / 100);

                // Determine status based on how underwater it is
                const pctDown = ((currentPrice - avgPrice) / avgPrice) * 100;
                let status = 'otm';
                let statusText = 'RECOVERING';
                if (pctDown < -20) {
                    status = 'itm';
                    statusText = 'DEEP RED';
                } else if (pctDown < -10) {
                    status = 'atm';
                    statusText = 'UNDERWATER';
                }

                return `
                    <tr>
                        <td><strong>${pos.symbol}</strong></td>
                        <td>${Math.round(shares)} <span style="opacity: 0.6; font-size: 11px;">(${contracts} contracts)</span></td>
                        <td>${formatCurrency(avgPrice)}</td>
                        <td>${formatCurrency(currentPrice)}</td>
                        <td class="${plClass}">${plSign}${formatCurrency(unrealizedPL)}</td>
                        <td><span class="status-badge ${status}">${statusText}</span></td>
                    </tr>
                `;
            }).join('');

            if (tbody) tbody.innerHTML = html;
            if (tbodyMain) tbodyMain.innerHTML = html;
        }

        // Activity Feed Functions
        let currentFeedFilter = 'all';

        function formatTimeAgo(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);

            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function generateOrderDescription(order) {
            const ticker = order.chain_symbol || 'Unknown';
            const state = order.state || 'unknown';
            const direction = order.direction || order.processed_premium_direction || '';
            const isCredit = direction === 'credit';
            const quantity = parseFloat(order.quantity) || 0;
            const premium = parseFloat(order.processed_premium) || parseFloat(order.premium) || 0;

            // Get leg info
            const legs = order.legs || [];
            const leg = legs[0] || {};
            const optionType = leg.option_type || 'option';
            const strike = parseFloat(leg.strike_price) || 0;
            const expiration = leg.expiration_date || '';
            const side = leg.side || '';
            const effect = leg.position_effect || '';

            // Detect strategy type
            const strategy = order.opening_strategy || order.closing_strategy || '';
            const isRoll = legs.length > 1 || strategy.includes('roll');
            const isCSP = strategy.includes('short_put') || (optionType === 'put' && side === 'sell');
            const isCC = strategy.includes('short_call') || (optionType === 'call' && side === 'sell');

            let description = '';
            let strategyLabel = '';

            if (isRoll && legs.length > 1) {
                // Multi-leg roll
                const buyLeg = legs.find(l => l.side === 'buy');
                const sellLeg = legs.find(l => l.side === 'sell');
                strategyLabel = 'roll';

                if (buyLeg && sellLeg) {
                    const buyStrike = parseFloat(buyLeg.strike_price) || 0;
                    const sellStrike = parseFloat(sellLeg.strike_price) || 0;
                    const sellExp = sellLeg.expiration_date || '';
                    const sellType = sellLeg.option_type || 'option';

                    description = `<strong>Rolled position!</strong> Closed $${buyStrike} ${buyLeg.option_type?.toUpperCase() || ''} and opened $${sellStrike} ${sellType.toUpperCase()} expiring ${formatDate(sellExp)}.`;

                    if (isCredit) {
                        description += ` Collected <strong>$${premium.toFixed(2)}</strong> net credit.`;
                    } else {
                        description += ` Paid <strong>$${premium.toFixed(2)}</strong> net debit.`;
                    }
                }
            } else if (state === 'filled') {
                if (isCSP) {
                    strategyLabel = 'csp';
                    description = `<strong>Cash-Secured Put opened!</strong> Sold ${quantity} ${ticker} $${strike} PUT expiring ${formatDate(expiration)}. Collected <strong>$${premium.toFixed(2)}</strong> premium.`;
                } else if (isCC) {
                    strategyLabel = 'cc';
                    description = `<strong>Covered Call opened!</strong> Sold ${quantity} ${ticker} $${strike} CALL expiring ${formatDate(expiration)}. Collected <strong>$${premium.toFixed(2)}</strong> premium.`;
                } else if (side === 'buy' && effect === 'close') {
                    strategyLabel = optionType === 'put' ? 'csp' : 'cc';
                    description = `<strong>Position closed!</strong> Bought to close ${quantity} ${ticker} $${strike} ${optionType.toUpperCase()}. Paid <strong>$${premium.toFixed(2)}</strong>.`;
                } else {
                    strategyLabel = optionType === 'put' ? 'csp' : 'cc';
                    description = `Executed ${side} ${optionType} at $${strike} strike, expiring ${formatDate(expiration)}.`;
                }
            } else if (state === 'cancelled') {
                strategyLabel = optionType === 'put' ? 'csp' : 'cc';
                description = `<strong>Order cancelled.</strong> ${quantity} ${ticker} $${strike} ${optionType.toUpperCase()} was not filled.`;
            } else if (state === 'pending' || state === 'queued' || state === 'confirmed') {
                strategyLabel = optionType === 'put' ? 'csp' : 'cc';
                description = `<strong>Order pending.</strong> ${side === 'sell' ? 'Selling' : 'Buying'} ${quantity} ${ticker} $${strike} ${optionType.toUpperCase()} at $${(premium/100/quantity).toFixed(2)}/share.`;
            } else {
                description = `${ticker} ${optionType} order - ${state}`;
            }

            return { description, strategyLabel, isCredit, premium };
        }

        function renderFeed(orders) {
            const container = document.getElementById('feedContainer');

            if (!orders || orders.length === 0) {
                container.innerHTML = '<div class="empty-state">No orders found</div>';
                return;
            }

            // Sort by date descending (most recent first)
            const sortedOrders = [...orders].sort((a, b) => {
                const dateA = new Date(a.created_at || a.updated_at || 0);
                const dateB = new Date(b.created_at || b.updated_at || 0);
                return dateB - dateA;
            });

            // Filter orders based on current filter
            const filteredOrders = sortedOrders.filter(order => {
                if (currentFeedFilter === 'all') return true;
                if (currentFeedFilter === 'filled') return order.state === 'filled';
                if (currentFeedFilter === 'pending') return ['pending', 'queued', 'confirmed'].includes(order.state);
                if (currentFeedFilter === 'cancelled') return order.state === 'cancelled';
                return true;
            });

            // Update stats
            const totalOrders = orders.length;
            const filledOrders = orders.filter(o => o.state === 'filled').length;
            const totalPremium = orders
                .filter(o => o.state === 'filled' && (o.direction === 'credit' || o.processed_premium_direction === 'credit'))
                .reduce((sum, o) => sum + (parseFloat(o.processed_premium) || 0), 0);
            const lastOrder = sortedOrders[0];
            const lastActivity = lastOrder ? formatTimeAgo(new Date(lastOrder.created_at || lastOrder.updated_at)) : '--';

            document.getElementById('feedTotalOrders').textContent = totalOrders;
            document.getElementById('feedFilledOrders').textContent = filledOrders;
            document.getElementById('feedTotalPremium').textContent = formatCurrency(totalPremium);
            document.getElementById('feedLastActivity').textContent = lastActivity;

            // Render feed items
            if (filteredOrders.length === 0) {
                container.innerHTML = '<div class="empty-state">No orders match this filter</div>';
                return;
            }

            container.innerHTML = filteredOrders.map(order => {
                const { description, strategyLabel, isCredit, premium } = generateOrderDescription(order);
                const ticker = order.chain_symbol || 'Unknown';
                const orderDate = new Date(order.created_at || order.updated_at);
                const state = order.state || 'unknown';

                return `
                    <div class="feed-item ${isCredit ? 'credit' : 'debit'}">
                        <div class="feed-header">
                            <div>
                                <span class="feed-ticker">${ticker}</span>
                                <span class="feed-strategy ${strategyLabel}">${strategyLabel.toUpperCase() || state.toUpperCase()}</span>
                            </div>
                            <span class="feed-premium ${isCredit ? 'credit' : 'debit'}">${isCredit ? '+' : '-'}$${premium.toFixed(2)}</span>
                        </div>
                        <div class="feed-description">${description}</div>
                        <div class="feed-meta">
                            <span class="feed-date">${orderDate.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' })}</span>
                            <span>${formatTimeAgo(orderDate)}</span>
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Feed filter click handlers
        document.querySelectorAll('.feed-filter').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.feed-filter').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentFeedFilter = btn.dataset.filter;
                renderFeed(optionsOrders);
            });
        });

        // Cache Functions
        function saveToCache(data) {
            try {
                localStorage.setItem(CACHE_KEY, JSON.stringify({
                    timestamp: Date.now(),
                    data: data
                }));
            } catch (e) {
                console.warn('Failed to save to cache:', e);
            }
        }

        function loadFromCache() {
            try {
                const cached = localStorage.getItem(CACHE_KEY);
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (e) {
                console.warn('Failed to load from cache:', e);
            }
            return null;
        }

        // Main Data Fetch
        async function refreshData() {
            const refreshBtn = document.getElementById('refreshBtn');
            refreshBtn.disabled = true;
            refreshBtn.textContent = 'Loading...';

            try {
                updateStatus('', 'Fetching...');

                const [portfolio, positions, orders] = await Promise.all([
                    fetchPortfolio(),
                    fetchOptionsPositions(),
                    fetchOptionsOrders()
                ]);

                portfolioData = portfolio;
                optionsPositions = positions;
                optionsOrders = orders;
                lastFetchTime = Date.now();

                // Save to cache
                saveToCache({ portfolio, positions, orders });

                // Hide error banner
                document.getElementById('errorBanner').classList.remove('visible');
                updateStatus('', 'Connected');

                // Render everything
                renderAll();

            } catch (error) {
                console.error('Failed to fetch data:', error);
                updateStatus('offline', 'API Offline');
                document.getElementById('errorBanner').classList.add('visible');

                // Try to load from cache
                const cached = loadFromCache();
                if (cached) {
                    portfolioData = cached.data.portfolio;
                    optionsPositions = cached.data.positions;
                    optionsOrders = cached.data.orders;
                    renderAll();
                    updateStatus('stale', 'Using cached data');
                }
            } finally {
                refreshBtn.disabled = false;
                refreshBtn.textContent = 'Refresh';
            }
        }

        function renderAll() {
            const stockPrices = getStockPrices(portfolioData);
            const { csps, ccs } = processPositions(optionsPositions, stockPrices);
            renderSummaryCards(portfolioData, optionsPositions, stockPrices);
            renderCSPTable(csps);
            renderCCTable(ccs);
            renderSuggestions(optionsPositions, optionsOrders, stockPrices);
            renderCharts(optionsOrders);
            renderFeed(optionsOrders);
            renderAssignments(portfolioData);
        }

        // Check for stale data
        function checkStaleData() {
            if (lastFetchTime && Date.now() - lastFetchTime > REFRESH_INTERVAL * 2) {
                updateStatus('stale', 'Data may be stale');
            }
        }

        // Initialize
        async function init() {
            // Check if already authenticated
            checkAuthOnLoad();

            // Load cached data first for immediate display
            const cached = loadFromCache();
            if (cached) {
                portfolioData = cached.data.portfolio;
                optionsPositions = cached.data.positions;
                optionsOrders = cached.data.orders;
                renderAll();
            }

            // Then fetch fresh data
            await refreshData();

            // Set up auto-refresh
            refreshTimer = setInterval(refreshData, REFRESH_INTERVAL);

            // Check for stale data periodically
            setInterval(checkStaleData, 30000);
        }

        // Start the dashboard
        init();
    </script>
</body>
</html>
